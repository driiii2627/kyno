{"version":3,"sources":["../../../../src/lib/supabase.ts","../../../../src/services/content.ts","../../../../src/services/tmdb.ts","../../../../.next-internal/server/app/details/%5Bid%5D/page/actions.js%20%28server%20actions%20loader%29","../../../../src/app/actions.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;\r\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;\r\n\r\n// Client for client-side operations (public read)\r\nexport const supabase = createClient(supabaseUrl, supabaseAnonKey);\r\n\r\n// Helper to get service role client (server-side only, for writes/admin)\r\nexport const getServiceSupabase = () => {\r\n    const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\r\n    if (!serviceRoleKey) {\r\n        throw new Error('Missing SUPABASE_SERVICE_ROLE_KEY environment variable');\r\n    }\r\n    return createClient(supabaseUrl, serviceRoleKey);\r\n};\r\n","import { supabase, getServiceSupabase } from '@/lib/supabase';\r\nimport { tmdb, Movie, MovieDetails } from './tmdb';\r\n\r\n// Interface matching the ACTUAL Supabase table structure (Database Schema)\r\nexport interface SupabaseContent {\r\n    id: string;\r\n    tmdb_id: number;\r\n    video_url: string;\r\n    title?: string;\r\n    description?: string; // DB column is description, not overview\r\n    poster_url?: string;  // DB column is poster_url\r\n    backdrop_url?: string; // DB column is backdrop_url\r\n    release_year?: number; // DB column is release_year\r\n    rating?: number;       // DB column is rating\r\n    genre?: string;\r\n    duration?: number;\r\n    created_at: string;\r\n}\r\n\r\n// Interface for the combined data (Supabase ID + TMDB Metadata)\r\nexport interface CatalogItem extends Movie {\r\n    video_url: string;\r\n    supabase_id: string;\r\n    genre?: string;\r\n    genres?: { id: number; name: string }[];\r\n    duration?: number;\r\n}\r\n\r\n/**\r\n * Service to manage content from Supabase Catalog\r\n */\r\nexport const contentService = {\r\n\r\n    /**\r\n     * Get a config value from app_config table\r\n     */\r\n    async getAppConfig(key: string, defaultValue: string): Promise<string> {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('app_config')\r\n                .select('value')\r\n                .eq('key', key)\r\n                .single();\r\n\r\n            if (error || !data) {\r\n                // Return default if not found or error\r\n                return defaultValue;\r\n            }\r\n            return data.value;\r\n        } catch (e) {\r\n            console.error(`Failed to fetch config for ${key}`, e);\r\n            return defaultValue;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Get a single movie by UUID (Lightweight lookup for Player)\r\n     */\r\n    async getMovieById(uuid: string): Promise<{ tmdb_id: number; video_url: string | null } | null> {\r\n        const { data, error } = await supabase\r\n            .from('movies')\r\n            .select('tmdb_id, video_url')\r\n            .eq('id', uuid)\r\n            .single();\r\n\r\n        if (error || !data) return null;\r\n        return { tmdb_id: data.tmdb_id, video_url: data.video_url };\r\n    },\r\n\r\n    /**\r\n     * Get a single series by UUID\r\n     */\r\n    async getSeriesById(uuid: string): Promise<{ tmdb_id: number; video_url: string | null } | null> {\r\n        const { data, error } = await supabase\r\n            .from('series')\r\n            .select('tmdb_id, video_url')\r\n            .eq('id', uuid)\r\n            .single();\r\n\r\n        if (error || !data) return null;\r\n        return { tmdb_id: data.tmdb_id, video_url: data.video_url };\r\n    },\r\n\r\n    /**\r\n     * Generic lookup to find item by UUID in either table\r\n     */\r\n    async getItemByUuid(uuid: string): Promise<{ type: 'movie' | 'tv'; tmdb_id: number; video_url: string | null } | null> {\r\n        // Run both checks in parallel\r\n        const [movie, series] = await Promise.all([\r\n            this.getMovieById(uuid),\r\n            this.getSeriesById(uuid)\r\n        ]);\r\n\r\n        if (movie) return { type: 'movie', ...movie };\r\n        if (series) return { type: 'tv', ...series };\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n    * Find item by TMDB ID\r\n    */\r\n    async getItemByTmdbId(tmdbId: number, type: 'movie' | 'tv'): Promise<{ data: { id: string } | null, error: any }> {\r\n        const table = type === 'movie' ? 'movies' : 'series';\r\n\r\n        const { data, error } = await supabase\r\n            .from(table)\r\n            .select('id')\r\n            .eq('tmdb_id', tmdbId)\r\n            .single();\r\n\r\n        return { data, error };\r\n    },\r\n\r\n    /**\r\n     * Syncs a list of TMDB movies to Supabase\r\n     * Uses Service Role to bypass RLS for inserts\r\n     */\r\n    async syncMovies(movies: Movie[]) {\r\n        if (!movies.length) return;\r\n\r\n        try {\r\n            const adminClient = getServiceSupabase();\r\n            const baseUrl = await this.getAppConfig('superflix_base_url', 'https://superflixapi.buzz');\r\n\r\n            const payload = movies.map(m => {\r\n                let year = 2025;\r\n                const dateStr = m.release_date || m.first_air_date;\r\n                if (dateStr) {\r\n                    const parsed = new Date(dateStr);\r\n                    if (!isNaN(parsed.getTime())) year = parsed.getFullYear();\r\n                }\r\n\r\n                const details = m as MovieDetails;\r\n                const genreStr = details.genres ? details.genres.map(g => g.name).join(', ') : '';\r\n                const duration = details.runtime || 0;\r\n                const generatedUrl = `${baseUrl}/filme/${m.id}`;\r\n\r\n                return {\r\n                    tmdb_id: m.id,\r\n                    video_url: generatedUrl,\r\n                    title: m.title || m.name || 'Sem Título',\r\n                    description: m.overview || '',\r\n                    poster_url: m.poster_path || '',\r\n                    backdrop_url: m.backdrop_path || '',\r\n                    release_year: year,\r\n                    rating: typeof m.vote_average === 'number' ? m.vote_average : 0,\r\n                    genre: genreStr,\r\n                    duration: duration,\r\n                    type: 'movie'\r\n                };\r\n            });\r\n\r\n            const { error } = await adminClient\r\n                .from('movies')\r\n                .upsert(payload, { onConflict: 'tmdb_id', ignoreDuplicates: false });\r\n\r\n            if (error) console.error(\"Sync Movies Error:\", error);\r\n        } catch (e) {\r\n            console.error(\"Sync Movies Exception:\", e);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Syncs a list of TMDB series to Supabase\r\n     */\r\n    async syncSeries(series: Movie[]) {\r\n        if (!series.length) return;\r\n\r\n        try {\r\n            const adminClient = getServiceSupabase();\r\n            const baseUrl = await this.getAppConfig('superflix_base_url', 'https://superflixapi.buzz');\r\n\r\n            const payload = series.map(s => {\r\n                let year = 2025;\r\n                const dateStr = s.first_air_date || s.release_date;\r\n                if (dateStr) {\r\n                    const parsed = new Date(dateStr);\r\n                    if (!isNaN(parsed.getTime())) year = parsed.getFullYear();\r\n                }\r\n\r\n                const details = s as MovieDetails;\r\n                const genreStr = details.genres ? details.genres.map(g => g.name).join(', ') : '';\r\n                const generatedUrl = `${baseUrl}/serie/${s.id}`;\r\n\r\n                return {\r\n                    tmdb_id: s.id,\r\n                    video_url: generatedUrl,\r\n                    title: s.name || s.title || 'Sem Título',\r\n                    description: s.overview || '',\r\n                    poster_url: s.poster_path || '',\r\n                    backdrop_url: s.backdrop_path || '',\r\n                    release_year: year,\r\n                    rating: typeof s.vote_average === 'number' ? s.vote_average : 0,\r\n                    genre: genreStr\r\n                };\r\n            });\r\n\r\n            const { error } = await adminClient\r\n                .from('series')\r\n                .upsert(payload, { onConflict: 'tmdb_id', ignoreDuplicates: false });\r\n\r\n            if (error) console.error(\"Sync Series Error:\", error);\r\n        } catch (e) {\r\n            console.error(\"Sync Series Exception:\", e);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Get all movies from the catalog (Fast - DB Only)\r\n     */\r\n    async getCatalogMovies(): Promise<CatalogItem[]> {\r\n        const { data: dbMovies, error } = await supabase\r\n            .from('movies')\r\n            .select('*')\r\n            .order('created_at', { ascending: false });\r\n\r\n        if (error) {\r\n            console.error('Error fetching movies from Supabase:', error);\r\n            return [];\r\n        }\r\n\r\n        if (!dbMovies) return [];\r\n\r\n        // Map directly from DB columns to CatalogItem interface\r\n        return dbMovies.map((dbMovie: SupabaseContent) => ({\r\n            id: dbMovie.tmdb_id,\r\n            title: dbMovie.title || 'Sem Título',\r\n            poster_path: dbMovie.poster_url,\r\n            backdrop_path: dbMovie.backdrop_url,\r\n            overview: dbMovie.description,\r\n            vote_average: dbMovie.rating || 0,\r\n            release_date: dbMovie.release_year?.toString(),\r\n            video_url: dbMovie.video_url,\r\n            supabase_id: dbMovie.id,\r\n            genre: dbMovie.genre,\r\n            // Construct a fake genre object if needed by UI, or just rely on 'genre' string\r\n            genres: dbMovie.genre ? [{ id: 0, name: dbMovie.genre }] : [],\r\n            duration: dbMovie.duration\r\n        })) as CatalogItem[];\r\n    },\r\n\r\n    /**\r\n     * Get all series from the catalog (Fast - DB Only)\r\n     */\r\n    async getCatalogSeries(): Promise<CatalogItem[]> {\r\n        const { data: dbSeries, error } = await supabase\r\n            .from('series')\r\n            .select('*')\r\n            .order('created_at', { ascending: false });\r\n\r\n        if (error) {\r\n            console.error('Error fetching series from Supabase:', error);\r\n            return [];\r\n        }\r\n\r\n        if (!dbSeries) return [];\r\n\r\n        return dbSeries.map((dbSeriesItem: SupabaseContent) => ({\r\n            id: dbSeriesItem.tmdb_id,\r\n            name: dbSeriesItem.title || 'Sem Título',\r\n            title: dbSeriesItem.title || 'Sem Título',\r\n            poster_path: dbSeriesItem.poster_url,\r\n            backdrop_path: dbSeriesItem.backdrop_url,\r\n            overview: dbSeriesItem.description,\r\n            vote_average: dbSeriesItem.rating || 0,\r\n            first_air_date: dbSeriesItem.release_year?.toString(),\r\n            video_url: dbSeriesItem.video_url,\r\n            supabase_id: dbSeriesItem.id,\r\n            genre: dbSeriesItem.genre,\r\n            genres: dbSeriesItem.genre ? [{ id: 0, name: dbSeriesItem.genre }] : [],\r\n        })) as CatalogItem[];\r\n    }\r\n};\r\n","const TMDB_BASE_URL = process.env.NEXT_PUBLIC_TMDB_BASE_URL || 'https://api.themoviedb.org/3';\r\nconst API_KEY = process.env.TMDB_API_KEY || 'e407e3f55ac924320df3192273006442'; // Fallback for safety, but env var takes precedence\r\n\r\nexport interface Movie {\r\n  id: number;\r\n  title?: string;\r\n  name?: string;\r\n  overview: string;\r\n  backdrop_path: string | null;\r\n  poster_path: string | null;\r\n  vote_average: number;\r\n  release_date?: string;\r\n  first_air_date?: string;\r\n  genre_ids: number[];\r\n}\r\n\r\nexport const getImageUrl = (path: string | null, size: 'original' | 'w500' | 'w342' | 'w780' | 'w1280' | 'w154' | 'w92' = 'original') => {\r\n  if (!path) return '/placeholder.png';\r\n  return `https://image.tmdb.org/t/p/${size}${path}`;\r\n};\r\n\r\nexport const fetchFromTMDB = async <T>(endpoint: string, params: Record<string, string> = {}): Promise<T> => {\r\n  const url = new URL(`${TMDB_BASE_URL}${endpoint}`);\r\n  url.searchParams.append('api_key', API_KEY);\r\n  url.searchParams.append('language', 'pt-BR');\r\n\r\n  Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));\r\n\r\n  console.log(`[TMDB Request] ${url.toString()}`);\r\n\r\n  try {\r\n    const res = await fetch(url.toString(), {\r\n      next: { revalidate: 3600 },\r\n    });\r\n\r\n    if (!res.ok) {\r\n      const errorBody = await res.text();\r\n      console.error(`[TMDB Error] ${res.status} ${res.statusText}: ${errorBody}`);\r\n      throw new Error(`TMDB Error: ${res.status}`);\r\n    }\r\n\r\n    return res.json();\r\n  } catch (error) {\r\n    console.error(\"[TMDB Fetch Error]\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport interface Genre {\r\n  id: number;\r\n  name: string;\r\n}\r\n\r\nexport interface MovieDetails extends Movie {\r\n  genres: Genre[];\r\n  runtime?: number;\r\n  episode_run_time?: number[];\r\n  number_of_seasons?: number;\r\n  seasons?: {\r\n    air_date: string;\r\n    episode_count: number;\r\n    id: number;\r\n    name: string;\r\n    overview: string;\r\n    poster_path: string;\r\n    season_number: number;\r\n    vote_average: number;\r\n  }[];\r\n}\r\n\r\nexport interface Episode {\r\n  id: number;\r\n  name: string;\r\n  overview: string;\r\n  still_path: string | null;\r\n  episode_number: number;\r\n  season_number: number;\r\n  runtime?: number;\r\n}\r\n\r\nexport interface SeasonDetails {\r\n  _id: string;\r\n  air_date: string;\r\n  episodes: Episode[];\r\n  name: string;\r\n  overview: string;\r\n  id: number;\r\n  poster_path: string | null;\r\n  season_number: number;\r\n}\r\n\r\nexport const tmdb = {\r\n  getTrending: async (type: 'movie' | 'tv' = 'movie') => {\r\n    return fetchFromTMDB<{ results: Movie[] }>(`/trending/${type}/week`);\r\n  },\r\n  getPopular: async (type: 'movie' | 'tv' = 'movie') => {\r\n    return fetchFromTMDB<{ results: Movie[] }>(`/${type}/popular`);\r\n  },\r\n  getTopRated: async (type: 'movie' | 'tv' = 'movie') => {\r\n    return fetchFromTMDB<{ results: Movie[] }>(`/${type}/top_rated`);\r\n  },\r\n  getByGenre: async (genreId: number, type: 'movie' | 'tv' = 'movie') => {\r\n    return fetchFromTMDB<{ results: Movie[] }>(`/discover/${type}`, { with_genres: genreId.toString() });\r\n  },\r\n  getDetails: async (id: number, type: 'movie' | 'tv') => {\r\n    return fetchFromTMDB<MovieDetails>(`/${type}/${id}`);\r\n  },\r\n  getCredits: async (id: number, type: 'movie' | 'tv') => {\r\n    return fetchFromTMDB<Credits>(`/${type}/${id}/credits`);\r\n  },\r\n  getSeasonDetails: async (tvId: number, seasonNumber: number) => {\r\n    return fetchFromTMDB<SeasonDetails>(`/tv/${tvId}/season/${seasonNumber}`);\r\n  },\r\n  getRecommendations: async (id: number, type: 'movie' | 'tv') => {\r\n    const response = await fetchFromTMDB<{ results: Movie[] }>(`/${type}/${id}/recommendations`);\r\n    return response.results || [];\r\n  },\r\n  getCollectionDetails: async (collectionId: number) => {\r\n    return fetchFromTMDB<{ parts: Movie[] }>(`/collection/${collectionId}`);\r\n  }\r\n};\r\n\r\nexport interface Cast {\r\n  id: number;\r\n  name: string;\r\n  character: string;\r\n  profile_path: string | null;\r\n}\r\n\r\nexport interface Credits {\r\n  id: number;\r\n  cast: Cast[];\r\n  crew: any[];\r\n}\r\n","export {getProfilesAction as '0018c6db43529b3ca9c55f1a4bb647fb8415811d1d'} from 'ACTIONS_MODULE0'\nexport {createProfileAction as '407fa483aadb683ffaf8d267be44a2d4010bfbd905'} from 'ACTIONS_MODULE0'\nexport {updateProfileAction as '40c7e6cc5ffa74f4aaa5de5b158ce112ad5e6af404'} from 'ACTIONS_MODULE0'\nexport {deleteProfileAction as '40fc0c27050575de9cc323afb67bce1d8322753d08'} from 'ACTIONS_MODULE0'\nexport {switchProfileAction as '4009cb87dbf8261408287db81f95ca338a80372201'} from 'ACTIONS_MODULE0'\nexport {signOutAction as '00044a13b912e98127fb87132cc89613aabacf9b57'} from 'ACTIONS_MODULE0'\nexport {getActiveProfileAction as '0056cb79b9ec21b37d317dc696b43a5f5c326ae982'} from 'ACTIONS_MODULE0'\nexport {getSeason as '604e6f8cc0e894a8d01029d82fda6f5e2efe792dcc'} from 'ACTIONS_MODULE1'\n","'use server';\r\n\r\nimport { tmdb } from '@/services/tmdb';\r\nimport { contentService } from '@/services/content';\r\nimport { redirect } from 'next/navigation';\r\n\r\nexport async function getSeason(tvId: number, seasonNumber: number) {\r\n    const seasonData = await tmdb.getSeasonDetails(tvId, seasonNumber);\r\n\r\n    // Filter episodes available on Superflix (Two-step validation)\r\n    const filteredEpisodes = await Promise.all(\r\n        seasonData.episodes.map(async (ep) => {\r\n            try {\r\n                // 1. Get the wrapper page from Superflix API\r\n                const wrapperUrl = `https://superflixapi.buzz/serie/${tvId}/${seasonNumber}/${ep.episode_number}`;\r\n                const wrapperRes = await fetch(wrapperUrl, { cache: 'no-store' });\r\n                if (!wrapperRes.ok) return null;\r\n\r\n                const html = await wrapperRes.text();\r\n\r\n                // 2. Extract the real content link (Visualização button)\r\n                // Regex to find href in <a ... class=\"btn btn-secondary\">Visualização</a>\r\n                // or just any link that looks like a player link if class changes.\r\n                // The pattern observed is class=\"btn btn-secondary\" and text \"Visualização\"\r\n                // Match: <a href=\"(URL)\" class=\"btn btn-secondary\">Visualização</a>\r\n                const match = html.match(/href=\"([^\"]+)\"\\s+class=\"btn btn-secondary\">Visualização<\\/a>/);\r\n\r\n                if (!match || !match[1]) {\r\n                    // If no link found, it might not be available\r\n                    return null;\r\n                }\r\n\r\n                const targetUrl = match[1];\r\n\r\n                // 3. Check the real link status\r\n                const targetRes = await fetch(targetUrl, { method: 'HEAD', cache: 'no-store' });\r\n\r\n                // Pobreflix/Noveflix returns 404 if not found\r\n                return targetRes.status === 200 ? ep : null;\r\n\r\n            } catch (e) {\r\n                console.error(`Error checking ep ${ep.episode_number}:`, e);\r\n                return null;\r\n            }\r\n        })\r\n    );\r\n\r\n    return {\r\n        ...seasonData,\r\n        episodes: filteredEpisodes.filter(ep => ep !== null)\r\n    };\r\n}\r\n\r\n// Simple in-memory cache to avoid fetching the huge list on every request\r\n// In a serverless environment, this persists only for the lifetime of the container\r\nconst validIdsCache: {\r\n    movie: { timestamp: number; ids: Set<string> } | null;\r\n    tv: { timestamp: number; ids: Set<string> } | null;\r\n} = {\r\n    movie: null,\r\n    tv: null\r\n};\r\n\r\nconst CACHE_DURATION = 1000 * 60 * 60; // 1 hour\r\n\r\n/**\r\n * Verify if content exists on Superflix API using the /lista endpoint\r\n */\r\nasync function verifySuperflixContent(tmdbId: number, type: 'movie' | 'tv'): Promise<boolean> {\r\n    try {\r\n        const category = type === 'movie' ? 'movie' : 'serie';\r\n\r\n        // 1. Check Cache\r\n        const cached = validIdsCache[type];\r\n        if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {\r\n            return cached.ids.has(tmdbId.toString());\r\n        }\r\n\r\n        // 2. Fetch Fresh List\r\n        const url = `https://superflixapi.buzz/lista?category=${category}&type=tmdb&format=json`;\r\n        console.log(`Fetching Superflix list for ${category}...`);\r\n\r\n        const res = await fetch(url, { method: 'GET', cache: 'no-store' });\r\n\r\n        if (!res.ok) {\r\n            console.error(\"Superflix list fetch failed:\", res.status);\r\n            return false;\r\n        }\r\n\r\n        const idsArray: string[] = await res.json();\r\n        const idsSet = new Set(idsArray);\r\n\r\n        // 3. Update Cache\r\n        validIdsCache[type] = {\r\n            timestamp: Date.now(),\r\n            ids: idsSet\r\n        };\r\n\r\n        // 4. Verify\r\n        return idsSet.has(tmdbId.toString());\r\n\r\n    } catch (e) {\r\n        console.error(`Superflix verification failed for ${type} ${tmdbId}:`, e);\r\n        return false; // Fail safe\r\n    }\r\n}\r\n\r\n/**\r\n * Resolves a TMDB ID to a Kyno UUID.\r\n * 1. Checks if it exists in Supabase.\r\n * 2. If yes, returns UUID.\r\n * 3. If no, CHECKS SUPERFLIX AVAILABILITY.\r\n * 4. If available, syncs it (creates it) and returns new UUID.\r\n * 5. If not available, returns null.\r\n */\r\nexport async function resolveTmdbContent(tmdbId: number, type: 'movie' | 'tv') {\r\n    // 1. Check if already exists in Supabase\r\n    const { data: existing, error } = await contentService.getItemByTmdbId(tmdbId, type);\r\n\r\n    if (existing) {\r\n        return existing.id;\r\n    }\r\n\r\n    // 2. Fetch details from TMDB FIRST to validate eligibility (Release Date, Status)\r\n    try {\r\n        const details = await tmdb.getDetails(tmdbId, type);\r\n\r\n        // CHECK 1: Is it released?\r\n        const releaseDateStr = details.release_date || details.first_air_date;\r\n        if (!releaseDateStr) {\r\n            console.warn(`Content ${tmdbId} rejected: No release date.`);\r\n            return null;\r\n        }\r\n\r\n        const releaseDate = new Date(releaseDateStr);\r\n        const today = new Date();\r\n\r\n        // Allow a small buffer (e.g., 2 days) for timezone diffs, but generally strictly past\r\n        if (releaseDate > today) {\r\n            // console.warn(`Content ${tmdbId} rejected: Future release date (${releaseDateStr}).`);\r\n            return null;\r\n        }\r\n\r\n        // CHECK 2: Status check (if available)\r\n        // Movies usually have 'status'. 'Released' is what we want. 'Post Production' etc should be blocked.\r\n        if ('status' in details && details.status !== 'Released' && details.status !== 'Returning Series' && details.status !== 'Ended') {\r\n            // console.warn(`Content ${tmdbId} rejected: Status is ${details.status}`);\r\n            return null;\r\n        }\r\n\r\n        // CHECK 3: Superflix Availability (Final Gate)\r\n        const isAvailable = await verifySuperflixContent(tmdbId, type);\r\n        if (!isAvailable) {\r\n            return null;\r\n        }\r\n\r\n        // 3. Sync to Supabase\r\n        if (type === 'movie') {\r\n            await contentService.syncMovies([details]);\r\n        } else {\r\n            await contentService.syncSeries([details]);\r\n        }\r\n\r\n        // 4. Fetch the newly created item\r\n        const { data: newItem } = await contentService.getItemByTmdbId(tmdbId, type);\r\n        return newItem?.id;\r\n\r\n    } catch (e) {\r\n        console.error(\"Failed to resolve content\", e);\r\n        return null;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}